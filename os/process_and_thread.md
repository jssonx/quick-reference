# 进程与线程

 - 进程：运行的程序
 - 多线程：一个进程中的多个执行流
   - 共享变量
   - semaphore
   - mutex
   - lock
 - 多进程：独立内存
   - 变量独立
   - 共享内存
   - pipe
   - socket
   - RPC
     - RMI
     - HTTP/Rest


## 进程

### 进程的状态
 - 运行
 - 就绪
 - 阻塞
 - 
 - 创建
 - 结束

### 进程的控制
  - 创建
  - 终止
  - 阻塞
  - 唤醒

### 进程的上下文切换

 - 各个进程之间是共享 CPU 资源的
 - 在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执行
 - 那么这个一个进程切换到另一个进程运行，称为进程的上下文切换

任务是交给 CPU 运行的，那么在每个任务运行前，CPU 需要知道任务从哪里加载，又从哪里开始运行。所以操作系统需要设置好CPU的寄存器，以及程序计数器，用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。

系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。

上面说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：进程上下文切换、线程上下文切换和中断上下文切换。

**进程是由内核管理和调度的，所以进程的切换只能发生在内核态。**

**所以，进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**

通过加载进程的上下文数据实现进程的上下文切换。

## 线程

比进程更小的能独立运行的基本单位

线程满足以下特性：
1. 实体之间可以并发运行
2. 实体之间共享相同的地址空间
3. 各个线程之间可以共享地址空间和文件等资源

每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的

### 线程的上下文切换

线程与进程最大的区别在于：**线程是调度的基本单位，而进程则是资源拥有的基本单位。**

### 线程的实现

 - 用户线程（User Thread）：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理
 - 内核线程（Kernel Thread）：在内核中实现的线程，是由内核管理的线程
 - 轻量级进程（LightWeight Process）：在内核中来支持用户线程

用户线程是基于用户态的线程管理库来实现的，那么线程控制块（Thread Control Block, TCB） 也是在库里面来实现的，**对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。**

**所以，用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。**

内核线程是由**操作系统管理**的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。

## 调度

**选择一个进程运行这一功能是在操作系统中完成的，通常称为调度程序（scheduler）。**

先提前说明，这里的进程指只有主线程的进程，所以调度主线程就等于调度了整个进程。线程不是操作系统的调度单位

### 调度时机
在进程的生命周期中，当进程从一个运行状态到另外一状态变化的时候，其实会触发一次调度。

 - 从就绪态 -> 运行态：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行
 - 从运行态 -> 阻塞态：当进程发生 I/O 事件而阻塞时，操作系统必须选择另外一个进程运行
 - 从运行态 -> 结束态：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行

调度算法分为两类：
1. 非抢占式调度算法
2. 抢占式调度算法

### 调度原则
原则一：为了提高 CPU 利用率，在这种发送 I/O 事件致使 CPU 空闲的情况下，调度程序需要从就绪队列中选择一个进程来运行。

原则二：要提高系统的吞吐率，调度程序要权衡长任务和短任务进程的运行完成数量。

原则三：如果进程的等待时间很长而运行时间很短，那周转时间就很长，这不是我们所期望的，调度程序应该避免这种情况发生。

原则四：就绪队列中进程的等待时间也是调度程序所需要考虑的原则。

原则五：对于交互式比较强的应用，响应时间也是调度程序需要考虑的原则。

针对上面五个调度原则，总结如下：
1. CPU 利用率：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；
2. 系统吞吐量：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；
3. 周转时间：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好；
4. 等待时间：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；
5. 响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。

### 调度算法

1. 先来先服务调度算法
2. 最短作业优先调度算法
3. 高响应比优先调度算法
4. 时间片轮转调度算法
5. 最高优先级调度算法











